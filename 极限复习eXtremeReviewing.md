# 一 软件工程概述

> 软件的定义
>
> 软件的发展和软件危机
>
> 软件工程的概念

程序的定义：程序=算法+数据结构。

**软件的定义**：<u>软件是包括程序、数据及其相关文档的完整集合</u>。程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品。

---

软件危机：计算机软件在开发和维护过程中遇到一系列严重问题，导致软件行业的信任危机。具体表现在：

- 软件的开发成本难以估算，无法制定合理的开发计划。
- 用户的需求无法确切表达。
- 软件质量存在问题。
- 软件的可维护性差。
- 缺乏文档资料。

产生软件危机的原因：

- 软件系统本身的复杂性。
- 软件开发的方法和技术不合理不成熟。

---

软件工程定义：运用工程化原则和方法，组织软件开发解决软件危机。

软件工程的三要素：<u>方法、工具、过程</u>。方法提供了“如何做”的技术、工具提供了自动或半自动的软件支撑环境、过程将方法和工具综合起来以达到合理及时地进行计算机软件开发的目的。

**软件工程的目标**：在<u>给定成本和时间</u>的前提下，开发出满足用户需求且具有<u>正确性、可用性</u>等因素的软件产品。

软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量。（和上条类似）

软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。

# 二 生命周期模型

> 软件生命周期概念
>
> 传统软件生命周期模型
>
> 新型软件生命周期模型

软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量。

戴明环：PDCA——Plan，Do，Check，Action。

<u>软件工程过程</u>是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动：

- 软件规格说明：规定软件功能及其使用限制。
- 软件开发：产生满足规格说明的软件。
- 软件确认：通过有效性验证以保证软件能够满足客户要求。
- 软件演进：为了满足客户变更要求，软件在使用过程中不断地改进。

---

软件生命周期概念：软件产品从考虑其概念开始，到该产品不再使用为止的整个时期。包括<u>概念阶段、分析与设计阶段、构造阶段、移交和运行阶段</u>等不同时期。

软件生命周期六个基本步骤：<u>制定计划 P、需求分析 D、设计 D、程序编码 D、测试 C、运行维护 A</u>。

软件过程模型：从一个特定角度提出的对软件过程的概括描述，是对软件开发过程的抽象，包括构成软件过程的各种<u>活动、软件工件、参与角色</u>等。

**软件生命周期模型**：一个框架，描述整个软件生命周期内，软件开发、运行、维护所实施的全部<u>过程、活动、任务</u>。同时<u>描述生命周期不同阶段产生的软件工件（Artifact），明确活动的执行角色</u>等。

## 传统软件生命周期模型

传统模型种类：瀑布模型、演化模型、增量模型、喷泉模型、V&W 模型、螺旋模型、构件组装模型、快速应用开发模型、原型方法。

瀑布模型：<u>**是所有其他软件生命周期模型的基础**</u>。

- 文档驱动，本阶段的工作对象来自于上一阶段活动的输出文档。
- 优点：
  - 降低开发复杂度、提高透明性可管理性。
  - <u>推迟了软件实现，强调必须先分析和设计。</u>
  - 以文档评审等手段指导整个开发过程。
- 缺点：
  - 缺乏灵活性，无法解决需求不明或不准确的问题。
  - 风险控制能力较弱。
  - 文档过多时，增加工作量。文档并不能完全反映实际项目情况，导致错误结论。
- 适用范围：为早期软件开发消除非结构化软件、降低复杂度、促进软件工程化有显著作用。（就是没什么用）

演化模型：

- 提倡两次开发：第一次得到试验性的原型产品，探索可行性，明确需求。第二次在此基础上开发成品。
- 优点：
  - 明确用户需求、提高系统质量、降低开发风险。
- 缺点：
  - 难于管理、结构较差、技术不成熟。
  - 可能会抛弃瀑布模型的文档控制优点。
  - 缺乏设计，可能导致软件系统结构较差。
- 适用范围：需求不清楚、小型系统、开发周期短。

增量模型

- 首先对系统最核心或最清晰的需求进行分析、设计、实现、测试。再按优先级逐步对后续的需求进行上述开发工作。<u>结合了瀑布模型和演化模型的优点。</u>
- 优点：
  - 第一次增量实现系统核心功能，增强客户使用系统的信心。
  - 先开发核心功能，项目总体失败风险较低。
  - 最高优先级的功能先开发，得到最多测试，保障可靠性。
  - 增量在同一体系指导下进行集成，提高稳定性和可维护性。
- 缺点：
  - 难以选择增量粒度。
  - 难以确定所有需求。

喷泉模型（迭代模型）：

- 高情商：各个开发阶段没有特定次序要求，可以并行进行，可以随时补充遗漏的需求（低情商：想到什么做什么，瞎 JB 写）。
- 优点：提高开发效率、缩短开发周期。
- 缺点：难于管理。
- 适用于：需求不明晰。

V 和 W 模型：

- 在瀑布模型基础上改进，把测试活动提前，使得模型能够驾驭风险。

螺旋模型：

- 分为四个象限螺旋上升：制定计划、风险分析、实施工程、客户评价——进入下一回路。
- 适用于：开发周期长、风险高的大型软件。

构件组装模型：

- 模块化思想，使用复用构件库的组件搭建系统。

- 优点：
  - 软件复用、提高效率。
  - 允许多项目同时开发，降低费用、提高可维护性。
- 缺点：
  - 缺乏通用构建组装标准风险较大。
  - 构建可重用性与系统高效性不易协调。
  - 过分依赖构件，构件质量影响产品质量。

快速应用开发模型（RAD）：

- 开发周期 60-90 天，分小组同步进行软件各部分开发。
- 缺点：时间短，需要强沟通配合。不适合所有应用。
- 适用于：信息管理系统的开发。

原型方法：和增量好像也没什么区别。

- 主要用于明确需求。

## 新型软件生命周期模型

RUP 模型：基于瀑布模型演化而来。

- 软件生命周期分解为 4 各阶段：<u>初始阶段、细化阶段、构造阶段、移交阶段</u>。每个阶段结束于一个重要的<u>里程碑</u>。在阶段结尾评估是否满足阶段目标，评估通过允许项目进入下一阶段。
  - 初始阶段：软件目标里程碑。细化阶段：体系结构里程碑。构造阶段：运行能力里程碑。移交阶段：产品发布里程碑。
- 特点：用例驱动，软件体系结构为核心，应用迭代及增量。

XP 极限编程：基于敏捷建模思想，也是瀑布模型演化而来。

- 强调用户满意，开发人员可以对需求的变化作出快速反应。

# 三 软件需求分析

> 需求分析的对象、任务、目标
>
> 数据、功能、行为建模
>
> 需求类别

## 需求分析的对象、任务、目标

需求分析的必要性：允许开发人员对问题细化并构建分析模型：

- 数据模型：哪些数据进出系统、哪些数据需要存储？
- 功能模型：对数据进行处理的功能有哪些？
- 行为模型：数据进出系统和被系统功能处理的场景。

需求分析的对象：用户要求。

需求分析的任务：准确地定义新系统的目标，<u>回答</u>系统“做什么”的问题，**<u>编写需求规格说明书</u>**（结果）。

需求分析的目标：导出目标系统的逻辑模型，<u>解决</u>目标系统“做什么”的问题。

需求分析的操作性原则：

- 表示和理解问题的**信息域**（数据）。
- 定义软件**功能**。
- 表示软件**行为**。

用户需求说明书与软件需求规格说明书的区别：前者主要采用自然语言来表达用户需求，后者采用规范的建模语言表示。<u>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求。软件需求规格说明书是软件系统设计的直接依据。</u>

需求规格说明书的内容：需求分析模型。（描述系统需要做什么，而非如何做系统）

- 给出**当前系统及目标系统**的逻辑视图，以及**当前系统**的物理视图。
  - 逻辑模型给出软件要达到的功能和处理数据之间的关系，而非实现细节。
  - 物理模型给出业务环境中的业务实体和业务处理流程，是抽象出当前系统逻辑模型的基础。

~~常用的建模分析方法有：SA（面向数据流的结构化分析方法）、JSD（面向数据结构的 Jackson 方法）、OOA（面向对象的分析方法）等。~~

## 数据、功能、行为建模

数据模型：信息和内容关系、信息流、信息结构。

功能模型：对进入软件的信息和数据进行变换的模块，必须至少完成“输入、处理、输出”三个功能。

行为模型：大多数软件对来自外界的事件做出反应。行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示（状态机）。

## 需求类别

**功能需求**：列举出所开发软甲你在功能上应做什么（最主要需求）。

**性能需求**：给出所开发软件的技术性能指标。系统的实时性和其他时间要求（响应时间、处理时间、消息传送时间等）、资源配置要求、精确度、数据处理量等其他要求。

**环境需求**：软件系统运行时所处环境的要求。① 硬件方面，采用什么机型、有什么外部设备、数据通信接口等。② 软件方面，采用什么支操作系统、数据库管理系统等。③ 使用方面，需要使用部门在制度上、人员技术水平上具备什么样的条件等。

其他需求类别：

- 可靠性需求：软件的有效性和数据完整性。
- 安全保密需求。
- 用户界面需求。
- 资源使用需求：指所开发软件运行时所需的数据、软件、内存空间等各项资源。以及软件开发时的人力物力需求。
- 软件成本消耗与开发进度需求：软件项目立项之后，根据合同规定，对软件开发的进度和步骤费用提出要求，作为开发管理依据。
- 预估将来系统可能达到的目标：在开发过程中对系统将来可能的扩充与修改做准备。

# 四 面向对象分析

> 领域建模
>
> 用例建模

面向对象的需求分析建模：领域模型和用例模型。

- 领域模型表示需求分析阶段“当前系统”逻辑模型的静态结构及业务流程。
- 用例模型是“目标系统”的逻辑模型，定义了目标系统“做什么”的需求。由用例图、用例说明、系统顺序图 SSD、操作契约 Operation Contract 四部分组成。

<img src="极限复习eXtremeReviewing.assets/image-20210622104631834.png" alt="image-20210622104631834" style="zoom: 67%;" />

## UML 概念及画法

UML：面向对象的统一<u>建模</u>语言。是一种<u>建模语言规格说明</u>，是一种表示的标准。不是过程也不是方法，但允许任何一种过程和方法使用它。

4+1 视图：从不同视角为系统架构建模，形成系统的不同视图。分别为：

- 用例视图（用户模型视图、场景视图）：强调从用户角度看到的或需要的系统功能。
- 逻辑视图（结构模型视图、静态视图）：展现系统的静态或结构组成及特征。
- 进程试图（行为模型视图、过程视图、协作视图、动态视图）：描述设计的并发和同步等特性，关注系统非功能性需求。
- 构件视图（实现模型视图、开发视图）：关注代码的静态组织与管理。
- 部署视图（环境模型视图、物理视图）：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等）。

<img src="极限复习.assets/image-20210619221424589.png" alt="image-20210619221424589" style="zoom: 67%;" />

UML 的 9 个基本图：

- <u>用例图 Use Case Diagram：从用户的角度描述系统的功能。</u>
- <u>类图 Class Diagram：描述系统的静态结构（类及其相互关系）。</u>
- 对象图：描述系统在某个时刻的静态结构（对象及其相互关系）。
- <u>顺序图 Sequence Diagram：按时间顺序描述系统元素间的交互。</u>
- <u>协作图 Collaboration Diagram：按照时间空间的顺序描述系统元素间的交互和他们之间的关系。</u>
- 状态图：描述系统元素（对象）的状态条件和响应。
- 活动图：描述了系统元素之间的活动。
- 构件图：描述了实现系统的元素（类或包）组织。
- 部署图：描述了环境元素的配置并把实现系统的元素映射到配置上。

UML 视图与图的关系：

- 用例视图——用例图。
- 逻辑视图——类图、对象图、顺序图/协作图。
- 进程试图——状态图、活动图。
- 构件视图——构件图。
- 部署视图——部署图。

UML 图的画法：

- 类的基本结构：类名+属性+操作()。
  - 构建领域模型时，不需要操作()。

<img src="极限复习.assets/image-20210619234536567.png" alt="image-20210619234536567" style="zoom:50%;" />

- 类之间的关系：

<img src="极限复习.assets/image-20210619234402936.png" alt="image-20210619234402936" style="zoom:50%;" />

![image-20210622111204633](极限复习eXtremeReviewing.assets/image-20210622111204633.png)

![image-20210622111711074](极限复习eXtremeReviewing.assets/image-20210622111711074.png)

## 领域模型

领域模型：领域内**概念类**或**对象**的抽象可视化表示（将客观世界中的事物可视化抽象化）。主要用于概括地描述**业务背景**和重要的**业务流程**，通过类图和活动图展示。

- 业务背景：描述概念类之间的关系，表示成能够代表业务知识结构的<u>类图</u>。
- 业务流程：由角色及其执行的活动构成。由<u>活动图</u>描述。

创建领域模型的步骤：

1.  找出当前需求中的<u>候选概念类</u>。
2.  在领域模型中描述这些<u>概念类</u>。用问题域中的词汇对概念类命名，将与当前需求无关的概念类排除。
3.  在概念类之间<u>添加必要的关联</u>来记录关系。用关联、继承、组合/聚合表示。
4.  在概念类中<u>添加</u>用来实现需求必要的<u>属性</u>。

识别概念类或属性：

- 属性一般是可以赋值的（如数字、文本），而概念类不可以。
- 如果对一个名词是概念类还是属性不确定，将其作为概念类处理。
- 不存在名词到类的映射机制，因为自然语言具有二义性。

领域模型示例：

![image-20210622111104060](极限复习eXtremeReviewing.assets/image-20210622111104060.png)

## 用例模型

用例模型是“目标系统”的逻辑模型，定义了目标系统“做什么”的需求。由四部分组成：

- 用例图
- 用例说明
- 系统顺序图 SSD
- 操作契约 Operation Contract

---

用例图：由三个基本元素组成。

- Actor：称为角色或参与者，使用系统的对象（不一定是人）。
- Usecase：用例，描述<u>角色如何使用系统功能实现需求目标</u>的一组成功场景和一系列失败场景的集合。
- Association：角色和用例之间的关系、用例和子用例之间的关系。

用例图示例：

<img src="极限复习eXtremeReviewing.assets/image-20210622111424215.png" alt="image-20210622111424215" style="zoom:50%;" />

<img src="极限复习eXtremeReviewing.assets/image-20210622111823427.png" alt="image-20210622111823427"  />

---

系统顺序图 SSD：确定角色与系统之间的交互关系，以代码风格命名。包含：

- 角色。
- 代表软件系统的对象，一般使用 system 或系统命名。
- 角色与 system 之间的交互信息，简称消息或操作。

SSD 示例：

![image-20210622112350690](极限复习eXtremeReviewing.assets/image-20210622112350690.png)

![image-20210622112410658](极限复习eXtremeReviewing.assets/image-20210622112410658.png)

---

操作契约：为系统操作定义。领域模型中业务对象接收到系统事件后，执行必须的业务处理时各业务对象的状态以及系统操作执行的结果。

![image-20210622112621773](极限复习eXtremeReviewing.assets/image-20210622112621773.png)

操作契约示例：

![image-20210622112608057](极限复习eXtremeReviewing.assets/image-20210622112608057.png)

# 五 结构化需求分析方法

> 数据建模
>
> 功能建模
>
> 行为建模

数据建模：

- 概念性数据模型基于实体-关系（ER）法，也称为实体关系模型。描述了从用户角度看到的数据，反映用户现实环境，但与软件系统中的实现方法无关。

- 数据对象描述：描述了数据对象实体的名称及其所有属性。

- 数据对象的基数：一对一、一对多、多对多。

## 数据流图

功能建模：当数据或信息流过计算机系统时被系统功能所处理、加工、变换后再从系统输出处理后的数据，表现为**数据流图**。

数据流图的结构：由加工、外部实体、数据流、数据存储组成。

分层数据流图：

- 顶层数据流图：顶层流图仅包含一个加工，它代表被开发系统，其作用在于表明被开发系统的范围，以及它和周围环境的数据交换关系。
- 中间层数据流图：表示对其上层父图的细化。它的每一加工可以继续细化，形成子图。中间层次的多少视系统的复杂程度而定。
- 底层数据流图：是指加工不须再做分解的数据流图，称为“原子加工”。

![image-20210622140232571](极限复习eXtremeReviewing.assets/image-20210622140232571.png)

数据词典：对于数据流图中出现的所有被命名的图形元素加以定义，使得每一个图形元素的名字都有一个确切的解释。其定义应是严密的、精确的，不可有半点含混并消除二义性，它由以下内容组成：

- 数据流词条：唯一标识数据流的名称，简要介绍数据流作用。
- 数据元素词条：唯一标识数据元素的名称或编号，简要描述该数据元素的作用，以及位于哪个数据结构内。
- 数据文件词条：唯一标识数据文件的名称，简要描述改文件存放什么数据。
- 加工逻辑词条：唯一标识加工的名称，描述加工逻辑和规则，简述功能。
- 外部实体词条：唯一标识外部实体的名称，指明该实体的性质及与系统的关系。

---

行为建模：从特定视角出发描述系统行为，采用动态分析的方法。

常用的结构化动态分析方法：状态迁移图、时序图、Petri 网等。

# 六 软件设计的概念及原则

> 软件设计过程：概要设计、详细设计
>
> 软件设计模型
>
> <u>模块，模块的独立性</u>
>
> <u>面向对象的设计原则</u>
>
> 软件体系结构风格

一堆概念。

## 软件设计（概要设计、详细设计、设计模型）

软件概要设计：

- <u>制定设计规范。</u>
- <u>软件系统结构的总体设计。</u>
- 处理方式设计（性能设计）。
- 数据结构设计。
- 可靠性设计（质量设计）。
- 界面设计（需求的直接表达方式）。
- <u>编写软件概要设计说明书。</u>
- 概要设计评审。

软件详细设计：

- 确定软件各个功能模块内的算法以及各功能模块的内部数据组织。
- 描述各种算法。
- 编写软件详细设计说明书。
- 详细设计评审。

软件模型设计：

- 动态结构设计：以某种方式表示功能相应客户请求时处理数据的过程或条件。进一步解释各功能之间如何协调工作。
- 静态结构设计：包括软件的功能结构和数据结构。展示软件系统能满足所有需求的框架结构。

软件的设计活动：

- 系统结构设计、数据结构设计。
- 接口设计、过程设计。
- 界面设计、组件设计、优化设计等。

## 软件的模块化

模块（module）定义：这个软件可被划分成若干个**<u>可单独命名且可编址组成部分</u>**，这些部分称为模块。模块具有三个基本属性：

- 功能：做什么。
- 逻辑：怎么做。
- 状态：模块使用时的环境和条件。

模块的表示：

- 模块的外部特性：模块的名字、参数表、功能（对程序其他环境造成的影响）。
- 模块的内部特性：完成其功能的代码和内部数据。

模块的内聚性：内聚性越高，模块功能独立性越强。

| 内聚类型 | 描述                                                                                                |
| -------- | --------------------------------------------------------------------------------------------------- |
| 巧合内聚 | 内聚程度最低。模块内凑巧有一些程序段代码相同，又没有明确表现出独立的功能，应当抽象为一个新的模块。  |
| 逻辑内聚 | 把几种相关的功能组合在一起，每次调用由模块根据参数确定执行那一部分功能。（if-else）                 |
| 时间内聚 | 又称经典内聚。一般为多功能模块，各个功能的执行与时间有关。例如初始化模块、终止模块。                |
| 过程内聚 | 把流程图中的一部分划出组成模块。例如，把一个流程中的循环部分、判定部分、计算部分分成三个模块。      |
| 通信内聚 | 一个模块完成多个功能，各功能都在同一个数据结构上操作，每个功能有唯一入口。例如对某数据结构的 CRUD。 |
| 功能内聚 | 内聚程度最高。一个模块中各个部分都是完成某一具体功能必不可少的组成部分，紧密联系，不可分割。        |

模块的耦合性：耦合性越高，模块间联系越紧密，独立性越弱。应当避免高耦合。

| 耦合类型   | 描述                                                                                                                                 |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| 非直接耦合 | 耦合性最低。两个模块之间没有直接关系，通过父级模块控制和调用各自实现功能。                                                           |
| 数据耦合   | 一组模块通过参数表简单变量交换信息。                                                                                                 |
| 标记耦合   | 一组模块通过参数表传递记录信息。这个记录是某一数据结构的子结构，不是简单变量。（违反了通信内聚原则）                                 |
| 控制耦合   | 一个模块通过传送开关、标志、名字等控制信息明显地控制另一模块的功能。                                                                 |
| 外部耦合   | 一组模块都访问同一全局简单变量（而非数据结构），并且不通过参数表传递该变量信息。                                                     |
| 公共耦合   | 一组模块访问同一个公共数据环境。如全局数据结构、共享通信区、内存公共覆盖区等。                                                       |
| 内容耦合   | 耦合性最高。一个模块直接访问另一模块内部数据、不通过正常入口转到另一模块内部、两模块有部分代码重叠、一个模块有多个入口。（垃圾代码） |

## 面向对象的设计原则

原则：

- 单一职责原则：引起一个类<u>变化的原因</u>（职责）应该只有一个。
- 开闭原则：类、模块、函数可以扩展，但不能修改原有代码（Open for extension，Closed for modification）。
- 里氏替换原则：子类应当可以替换父类，并出现在父类能够出现的任何地方。
- 依赖倒置原则：
  - 高层模块不应依赖于底层模块，二者都应依赖于抽象。抽象不应依赖于细节，细节应该依赖于抽象。
  - 程序中所有依赖关系都应终止于抽象类或接口。
- 接口隔离原则：若一个服务类为多个客户类提供不同服务，则服务类针对每个不同服务都应该有一个接口。
- 组合/聚合复用原则：在一个新对象里面使用一些已有对象，使之成为新对象的一部分。新对象通过向已有对象委托（delegate）一部分职责而达到复用已有对象的目的。（不要继承，要组合/聚合）
- 迪米特法则：最少知识原则。一个对象应当尽可能少地了解其他对象。（对象只与 this、本对象方法中的参量、当前对象实例直接引用的对象、对象实例聚集中的其他元素、当前对象创建的对象通信）

## 软件体系结构风格

<u>软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式</u>（设计模式）：

- 管道和过滤器风格：参考 Unix/Linux。通过过滤器进行数据处理、通过管道进行信息流传递。

- 调用和返回风格：大型软件开发主流体系结构

  - 主程序/子程序风格：将程序化分为若干小片段，封装为子程序。主程序单线程控制。
  - <u>对象风格</u>：数据的表示方法和相应操作封装在抽象数据类型或对象中。对象通过函数和过程调用交互。
  - <u>分层风格</u>：将系统组织称一个结构，通过接口，每一层为上层提供服务，并作为下层的客户端。

- 基于事件的风格：构件不直接调用过程，而是声明或广播事件。其他构件通过向系统注册监听事件，完成相应操作。

- 客户端/服务器风格：应用程序的数据和处理分布在一定范围内的多个构件上，构件之间通过网络连接。

- <u>MVC 风格</u>：模型（数据与状态）与视图（显示）分离，通过控制器（封装若干接口）控制。

<img src="极限复习eXtremeReviewing.assets/image-20210622152317173.png" alt="image-20210622152317173" style="zoom:50%;" />

- 黑板风格：通常用于松散的构件访问共享数据的应用程序。（略？）

# 七 面向对象设计方法

> 面向对象设计步骤
>
> 模型层次化
>
> 面向对象的设计模式

面向对象的设计与 UML

面向对象的设计：以需求分析阶段的**用例模型**和**领域模型**为基础，运用 UML 构建软件系统结构，通过一系列设计模型说明用例的实现过程。

主要设计活动：选择架构——通过**UML 交互图**描述每个用例的实现——通过**UML 类图**给出满足所有用例的系统静态结构——根据系统设计原则进行优化。（存疑）

---

软件概要设计步骤：

- 选择合适的软件架构。（单机？CS 或 BS？云服务？）
- 系统的**动态结构设计**：
  - 针对用例 SSD 中的每个系统事件，使用 Sequence diagram/ Collaboration diagram 给出符合该系统事件操作契约的内容。
  - 如果软件对象具有多种不同职责，需要使用 State machines diagram 进行状态迁移设计。
- 系统的**静态结构设计**：
  - 对所有用例或子系统级别的用例交互图归纳，使用 Class diagram 给出系统的静态结构。

* 软件详细设计：

  - 针对系统静态结构中的每个方法，使用 Activity diagram 进行逻辑结构的设计。

* 软件架构：
  - 三种基础架构：单机、CS 和 BS、云服务。
  - 服务器端的分层：控制器层+应用逻辑层（必须）+基础架构层+持久化层+DB（必须）

---

模型层次化：层次化设计模型符合面向对象设计原则，并使系统易于扩展和维护。

- 用户界面层：尽量与业务分离，专门处理交互。
- 控制器层：专职接收 SSD 中的系统事件，进行 validation，并转发给应用逻辑层对象处理。
- 业务逻辑层：实现系统核心功能。
- 持久化层：负责 CRUD 经过业务逻辑层处理后的需要持久化（将对象状态永久保存到物理介质）的数据。与业务逻辑层功能分离，与数据库保持同步。持久化层将对数据库的操作类封装起来，向业务/领域对象提供持久化服务，是数据库变化对业务领域影响的范围局部化。
- 系统层：为应用封装操作系统相关的功能。

---

面向对象设计的关键步骤：在确定软件框架结构的基础上，进行如下内容设计：

- 发现对象（发现软件类）：根据需求和选择的架构和模式确定系统由哪些对象构成。

- 确定对象属性：明确对象特征属性。
- 确定对象行为：明确对象功能职责。
- 确定对象之间的关系：根据 SSD 和操作契约、选择的架构和模式，明确系统如何相互协作完成功能需求的交互过程。

---

面向对象的设计模式：

- <u>对象的职责通过调用对象的方法来实现。</u>
- <u>面向对象设计最关键的活动是正确地给对象分配职责。</u>
- <u>模式定义了一组相互协作的设计类，包括类的职责、类之间的交互方式。</u>

如何确定设计类并分配职责？类职责分配模式、控制器模式、建造者模式、信息专家模式。

<u>类职责分配（Grasp）模式</u>：

- 设计类的来源有两部分：

  - 核心逻辑由领域模型中的**概念类**转换而来。
  - 另一部分是为了实现新增的类，如负责对象持久化的类、负责通信的类。

- 每个设计类都有明确的职责，分为两种类型：

  - 了解型（knowing）职责（自己干自己的事）：

    - 对象了解自己私有的数据。
    - 对象了解相关联的对象。
    - 对象了解能够派生或计算的事物。

  - 行为型（doing）职责（自己干自己能干的事）：

    - 对象自身能执行一些行为，如创建一个对象或者进行计算。
    - 对象要能启动其他对象中的动作。
    - 对象要能控制或协调其他对象中的活动。

    职责的内聚（自己只干自己的事）：减少不必要的关联，提高内聚性。

控制器（Controller）模式：把处理和接收系统事件的职责分配给位于控制器层的对象。提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。

- 外观（facade）控制器：代表整个系统。
- 用例控制器或会话控制器：代表一个发生系统事件的用例场景。这个类通常命名为`<用例名>控制器`。
- 在相同的用例场景中使用同一个控制器类处理所有的系统事件。
- 一次会话是与一个参与者进行交谈的一个实例。

建造者（Creator）模式：用于<u>操作契约中对象实例的创建</u>。体现低耦合设计思想，<u>是迪米特法则的具体运用</u>。

- 若以下条件满足一个或多个：

  - B 聚合或包含 A，B 记录对象 A，B 密切使用对象 A，B 拥有创建对象 A 所需要的初始化数据。

  则可将创建类 A 实例的职责分配给类 B。

信息专家（Information Expert）模式：

- 这是<u>给对象分配职责的通用原则</u>：职责分配给拥有履行职责所必需信息的类（信息专家）完成。

---

创建交互图：根据选择的系统架构，使用 UML 的交互图，为该用例的每一个**系统事件**确定对应的软件对象，并根据操作契约确定对象之间的关系。

![image-20210622163157344](极限复习eXtremeReviewing.assets/image-20210622163157344.png)

---

创建设计类图：<u>设计类图定义类、类的属性和操作</u>，但不定义实现操作的算法。

- 扫描所有交互图以及领域模型中涉及的类，识别软件类。
- 将领域模型中已经识别出来的部分属性添加到类中。
- 根据交互图为软件类添加方法。忽略构造函数和 getter/setter。
- 添加更多类型信息。包括属性类型、方法参数类型、返回类型。
- 添加关联和导航。定义 A 到 B 带导航关联修饰的常见情况：A 发送一个消息到 B、A 创建一个 B 的实例、A 需要维护到 B 的一个连接。
- （可选）类成员的细节表示。如属性可见性、方法体的描述等。

例：

![image-20210622164057390](极限复习eXtremeReviewing.assets/image-20210622164057390.png)

<img src="极限复习eXtremeReviewing.assets/image-20210622164129242.png" alt="image-20210622164129242" style="zoom: 67%;" />

# 八 结构化设计方法

# 九 程序实现

# 十 软件测试
